<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Plant Logic Jump - Sprite Edition</title>
<style>
  html, body { margin: 0; padding: 0; overflow: hidden; background: #0a0a0a; font-family: 'Tahoma', sans-serif; }
  canvas { display: block; background: #111; }

  #ui-layer {
    position: absolute; top: 0; left: 0; width: 100%; height: 100%;
    display: none; flex-direction: column; align-items: center; justify-content: center;
    background: rgba(0, 0, 0, 0.85); color: white; z-index: 10; backdrop-filter: blur(4px);
  }
  .score-info { font-size: 128px; margin: 60px; }
  .best-info { font-size: 48px; color: #ffd700; margin-bottom: 30px; }
  .restart-btn {
    width: 300px; height: 300px; border-radius: 50%; background: #2ecc71;
    border: none; cursor: pointer; display: flex; align-items: center; justify-content: center;
    box-shadow: 0 0 20px rgba(46, 204, 113, 0.6); animation: pulse 2s infinite;
  }
  .restart-btn svg { fill: white; width: 150px; height: 150px; margin-left: 5px; }
  @keyframes pulse {
    0% { box-shadow: 0 0 0 0 rgba(46, 204, 113, 0.7); }
    70% { box-shadow: 0 0 0 20px rgba(46, 204, 113, 0); }
    100% { box-shadow: 0 0 0 0 rgba(46, 204, 113, 0); }
  }
  @keyframes tap-anim {
    0%, 100% { transform: scale(1); opacity: 0.4; }
    50% { transform: scale(1.2); opacity: 0.9; }
  }
</style>
</head>
<body>

<div id="ui-layer">
  <h1 style="font-size: 48px; color: #e74c3c;">Ù¾Ø§ÛŒØ§Ù† Ø¨Ø§Ø²ÛŒ</h1>
  <div id="final-score" class="score-info">Ø§Ù…ØªÛŒØ§Ø²: Û°</div>
<div id="best-score" class="best-info">Ø¨Ù‡ØªØ±ÛŒÙ† Ø±Ú©ÙˆØ±Ø¯: Û°</div> 
 <div id="edu-info" style="color: #ecf0f1; background: rgba(255,255,255,0.1);font-size: 36px; padding: 36px; border-radius: 32px; margin: 48px; max-width: 70%; line-height: 1.6; text-align: center;"></div>
  
  <button class="restart-btn" onclick="restartGame()">
    <svg viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg>
  </button>
  <p style="margin-top: 25px; font-weight: bold; color: #2ecc71;">Ø´Ø±ÙˆØ¹ Ø¯ÙˆØ¨Ø§Ø±Ù‡</p>
</div>

<div id="start-guide" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; justify-content: space-around; align-items: center; z-index: 5; pointer-events: none; background: rgba(0,0,0,0.3);">
  <div style="text-align:center; animation: tap-anim 1.5s infinite;">
    <span style="font-size: 50px;">ğŸ‘†</span>
    <p style="color:white; font-family: Tahoma;">Ù¾Ø±Ø´ Ø¨Ù‡ Ú†Ù¾</p>
  </div>
  <div style="text-align:center; animation: tap-anim 1.5s infinite 0.75s;">
    <span style="font-size: 50px;">ğŸ‘†</span>
    <p style="color:white; font-family: Tahoma;">Ù¾Ø±Ø´ Ø¨Ù‡ Ø±Ø§Ø³Øª</p>
  </div>
</div>

<canvas id="game"></canvas>

<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
const uiLayer = document.getElementById("ui-layer");

canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

const gravity = 1;
const jumpForce = -18;
const minGateDistance = 1800; 
const maxGateDistance = 2200;

let player, gates, obstacles, fallingObjects, lastGateY, score, highScore, shake, flashAlpha, currentGroundY;
let stormTimer = 1000; 
let stormDuration = 0; 
let gameState = 'playing';
let activeLaser = null;

// --- Ø¨Ø®Ø´ ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ø§Ø³Ù¾Ø±Ø§ÛŒØª Ú©Ø§Ø±Ø§Ú©ØªØ± ---
const playerSprite = new Image();
playerSprite.src = 'cards/player_sprite.png'; // Ù†Ø§Ù… ÙØ§ÛŒÙ„ Ø§Ø³Ù¾Ø±Ø§ÛŒØª Ø´Ù…Ø§
let spriteFrame = 0;
let gameFrame = 0;
const staggerFrames = 5; // Ø³Ø±Ø¹Øª ØªØ¹ÙˆÛŒØ¶ ÙØ±ÛŒÙ… (Ø¹Ø¯Ø¯ Ø¨ÛŒØ´ØªØ± = Ø§Ù†ÛŒÙ…ÛŒØ´Ù† Ú©Ù†Ø¯ØªØ±)
const spriteWidth = 64;  // Ø¹Ø±Ø¶ Ù‡Ø± ØªÚ© ÙØ±ÛŒÙ… Ø¯Ø± Ø§Ø³Ù¾Ø±Ø§ÛŒØªâ€ŒØ´ÛŒØª Ø´Ù…Ø§
const spriteHeight = 64; // Ø§Ø±ØªÙØ§Ø¹ Ù‡Ø± ØªÚ© ÙØ±ÛŒÙ… Ø¯Ø± Ø§Ø³Ù¾Ø±Ø§ÛŒØªâ€ŒØ´ÛŒØª Ø´Ù…Ø§
// ----------------------------------

highScore = localStorage.getItem("plantJumpBest") || 0;

const quizData = [
  { trait: "Ø¯Ø§Ù†Ù‡ Ù„ÙˆØ¨ÛŒØ§", correct: ["Ø¯Ùˆ Ù„Ù¾Ù‡ Ø§ÛŒ"], wrongs: ["ÛŒÚ© Ù„Ù¾Ù‡ Ø§ÛŒ"], images: {"Ø¯Ùˆ Ù„Ù¾Ù‡ Ø§ÛŒ": "lube_2.png", "ÛŒÚ© Ù„Ù¾Ù‡ Ø§ÛŒ": "lube_1.png"}, desc: ".Ø¯Ø§Ù†Ù‡ Ù„ÙˆØ¨ÛŒØ§ Ø¯Ùˆ Ù„Ù¾Ù‡ Ø§ÛŒ Ø§Ø³Øª" },
  { trait: "Ø±ÛŒØ´Ù‡ Ú¯Ù†Ø¯Ù…", correct: ["Ø§ÙØ´Ø§Ù†"], wrongs: ["Ø±Ø§Ø³Øª"], images: {"Ø§ÙØ´Ø§Ù†": "afshan.png", "Ø±Ø§Ø³Øª": "rast.png"}, desc: ".Ø±ÛŒØ´Ù‡ Ú¯Ù†Ø¯Ù… Ø§ÙØ´Ø§Ù† Ø§Ø³Øª" },
  { trait: "Ø±ÛŒØ´Ù‡ ÛŒ Ù…Ø´Ø§Ø¨Ù‡ Ø±ÛŒØ´Ù‡ Ø°Ø±Øª", correct: ["Ø¨Ø±Ù†Ø¬","Ú¯Ù†Ø¯Ù…"], wrongs: ["Ù†Ø®ÙˆØ¯","Ø¢ÙØªØ§Ø¨ Ú¯Ø±Ø¯Ø§Ù†"], images: {"Ø¨Ø±Ù†Ø¬": "b1.png", "Ú¯Ù†Ø¯Ù…": "g1.png", "Ù†Ø®ÙˆØ¯": "n1.png", "Ø¢ÙØªØ§Ø¨ Ú¯Ø±Ø¯Ø§Ù†": "a1.png"}, desc: " Ú¯ÛŒØ§Ù‡Ø§Ù†ÛŒ Ù…Ø§Ù†Ù†Ø¯ Ø°Ø±ØªØŒØ¨Ø±Ù†Ø¬ Ùˆ Ú¯Ù†Ø¯Ù… Ø±ÛŒØ´Ù‡ ÛŒ Ø§ÙØ´Ø§Ù† Ø¯Ø§Ø±Ù†Ø¯ " },
  { trait: "Ø¯Ø§Ù†Ù‡ Ø¯Ùˆ Ù„Ù¾Ù‡", correct: ["Ù„ÙˆØ¨ÛŒØ§", "Ù†Ø®ÙˆØ¯", "Ø¹Ø¯Ø³"], wrongs: ["Ú¯Ù†Ø¯Ù…", "Ø¬Ùˆ", "Ø°Ø±Øª"], images: {"Ù„ÙˆØ¨ÛŒØ§": "l1.png", "Ù†Ø®ÙˆØ¯": "n1.png", "Ø¹Ø¯Ø³": "a2.png", "Ú¯Ù†Ø¯Ù…": "g1.png", "Ø¬Ùˆ": "j1.png", "Ø°Ø±Øª": "z1.png"}, desc: "Ú¯ÛŒØ§Ù‡Ø§Ù†ÛŒ Ù…Ø§Ù†Ù†Ø¯ Ù„ÙˆØ¨ÛŒØ§ØŒÙ†Ø®ÙˆØ¯ Ùˆ Ø¹Ø¯Ø³ Ø¯Ø§Ù†Ù‡ Ø¯Ùˆ Ù„Ù¾Ù‡ Ø¯Ø§Ø±Ù†Ø¯" },
  { trait: "Ø±ÛŒØ´Ù‡ Ø§ÙØ´Ø§Ù†", correct: ["Ø¨Ø±Ù†Ø¬", "Ú¯Ù†Ø¯Ù…", "Ø°Ø±Øª"], wrongs: ["Ù†Ø®ÙˆØ¯", "Ù¾ÛŒØ§Ø²", "Ù‡ÙˆÛŒØ¬"], images: {"Ø¨Ø±Ù†Ø¬": "b1.png", "Ú¯Ù†Ø¯Ù…": "g1.png", "Ø°Ø±Øª": "z1.png", "Ù†Ø®ÙˆØ¯": "n1.png", "Ù¾ÛŒØ§Ø²": "p1.png", "Ù‡ÙˆÛŒØ¬": "h1.png"}, desc: "Ø¯Ø± Ø±ÛŒØ´Ù‡ Ø§ÙØ´Ø§Ù†ØŒ Ø±ÛŒØ´Ù‡ Ø§ØµÙ„ÛŒ Ù¾Ø³ Ø§Ø² Ù…Ø¯ØªÛŒ Ø§Ø² Ø¨ÛŒÙ† Ù…ÛŒâ€ŒØ±ÙˆØ¯ Ùˆ Ø±ÛŒØ´Ù‡â€ŒÙ‡Ø§ÛŒ Ù†Ø§Ø¨Ø¬Ø§ Ø¬Ø§ÛŒ Ø¢Ù† Ø±Ø§ Ù…ÛŒâ€ŒÚ¯ÛŒØ±Ù†Ø¯." },
  { trait: "Ú¯Ù„Ø¨Ø±Ú¯ Û³ ØªØ§ÛŒÛŒ", correct: ["Ø²Ù†Ø¨Ù‚", "Ù„Ø§Ù„Ù‡"], wrongs: ["Ø±Ø²", "Ù†Ø³ØªØ±Ù†", "Ú¯Ù„ Ø³Ø±Ø®"], images: {"Ø²Ù†Ø¨Ù‚": "zanbagh.png", "Ù„Ø§Ù„Ù‡": "lale.png", "Ø±Ø²": "rose.png", "Ù†Ø³ØªØ±Ù†": "nastaran.png", "Ú¯Ù„ Ø³Ø±Ø®": "sorkh.png"}, desc: "Ú¯ÛŒØ§Ù‡Ø§Ù† ØªÚ© Ù„Ù¾Ù‡ Ù…Ø¹Ù…ÙˆÙ„Ø§Ù‹ Ø¯Ø§Ø±Ø§ÛŒ Ú¯Ù„Ø¨Ø±Ú¯â€ŒÙ‡Ø§ÛŒÛŒ Ø¨Ø§ Ù…Ø¶Ø±Ø¨ Û³ Ù‡Ø³ØªÙ†Ø¯." },
  { trait: "Ø³Ø§Ù‚Ù‡ ØºØ¯Ù‡â€ŒØ§ÛŒ", correct: ["Ø³ÛŒØ¨â€ŒØ²Ù…ÛŒÙ†ÛŒ"], wrongs: ["Ù‡ÙˆÛŒØ¬", "ØªØ±Ø¨Ú†Ù‡", "Ø³ÛŒØ±"], images: {"Ø³ÛŒØ¨â€ŒØ²Ù…ÛŒÙ†ÛŒ": "potato.png", "Ù‡ÙˆÛŒØ¬": "carrot.png", "ØªØ±Ø¨Ú†Ù‡": "torob.png", "Ø³ÛŒØ±": "sir.png"}, desc: "Ø³ÛŒØ¨â€ŒØ²Ù…ÛŒÙ†ÛŒ ÛŒÚ© Ø³Ø§Ù‚Ù‡ ØªØºÛŒÛŒØ± Ø´Ú©Ù„ ÛŒØ§ÙØªÙ‡ Ø²ÛŒØ±Ø²Ù…ÛŒÙ†ÛŒ Ø§Ø³Øª." },
  { trait: "Ø¢ÙˆÙ†Ø¯ Ù†Ø¯Ø§Ø±Ù†Ø¯", correct: ["Ø®Ø²Ù‡â€ŒÙ‡Ø§"], wrongs: ["Ø³Ø±Ø®Ø³â€ŒÙ‡Ø§", "Ú©Ø§Ø¬â€ŒÙ‡Ø§", "Ú†Ù†Ø§Ø±"], images: {"Ø®Ø²Ù‡â€ŒÙ‡Ø§": "khaze.png", "Ø³Ø±Ø®Ø³â€ŒÙ‡Ø§": "sarkhas.png", "Ú©Ø§Ø¬â€ŒÙ‡Ø§": "kaj.png", "Ú†Ù†Ø§Ø±": "chenar.png"}, desc: "Ø®Ø²Ù‡â€ŒÙ‡Ø§ Ú¯ÛŒØ§Ù‡Ø§Ù† Ø¨Ø¯ÙˆÙ† Ø¢ÙˆÙ†Ø¯ Ù‡Ø³ØªÙ†Ø¯ Ú©Ù‡ Ø¯Ø± Ù…Ø­ÛŒØ·â€ŒÙ‡Ø§ÛŒ Ù…Ø±Ø·ÙˆØ¨ Ø²Ù†Ø¯Ú¯ÛŒ Ù…ÛŒâ€ŒÚ©Ù†Ù†Ø¯." }
];

const imageAssets = {};
function preloadImages() {
  const allPaths = [...new Set(quizData.flatMap(q => Object.values(q.images)))];
  allPaths.forEach(path => {
    const img = new Image();
    img.src = "cards/" + path;
    imageAssets[path] = img;
  });
}
preloadImages();

function createGate(y) {
  const quiz = quizData[Math.floor(Math.random() * quizData.length)];
  let chance3 = Math.min(score * 5, 40); 
  let chance4 = Math.min(score * 0.6, 30); 
  const rand = Math.random() * 100;
  let numOptions = (rand < chance4) ? 4 : (rand < (chance4 + chance3) ? 3 : 2);
  let numCorrectsNeeded = (numOptions >= 3 && quiz.correct.length >= 2 && Math.random() > 0.5) ? 2 : 1;
  let selectedCorrects = [...quiz.correct].sort(() => 0.5 - Math.random()).slice(0, numCorrectsNeeded);
  let selectedWrongs = [...quiz.wrongs].sort(() => 0.5 - Math.random()).slice(0, numOptions - selectedCorrects.length);
  let options = [...selectedCorrects, ...selectedWrongs].sort(() => 0.5 - Math.random());
  let vx = 0;
  if (score >= 3) {
    let moveChance = Math.min((score - 3) * 10, 70); 
    if (Math.random() * 100 < moveChance) vx = (1.5 + Math.random() * 2.5) * (Math.random() > 0.5 ? 1 : -1);
  }
  return { y, x: 0, vx, h: 60, quiz, options, scored: false };
}

function spawnObstaclesBetween(startY, endY) {
  const sectionHeight = 450; 
  const numSections = Math.floor(Math.abs(endY - startY) / sectionHeight);
  for (let i = 0; i < numSections; i++) {
    if (Math.random() > 0.4) {
      const rowY = startY + (i * sectionHeight) + 150;
      const isMoving = Math.random() > 0.5;
      const oWidth = 140 + Math.random() * 120;
      const oHeight = 60 + Math.random() * 30;
      obstacles.push({
        x: Math.random() * (canvas.width - oWidth),
        y: rowY, w: oWidth, h: oHeight,
        vx: isMoving ? (1.5 + Math.random() * 2.5) * (Math.random() > 0.5 ? 1 : -1) : 0,
        color: isMoving ? "#e74c3c" : "#7f8c8d"
      });
    }
  }
}

function manageFallingStorm() {
  if (score < 10 || !player.alive) return; // Ø´Ø±Ø· Ø´Ø±ÙˆØ¹ (Ù…Ø«Ù„Ø§Ù‹ Ø¨Ø¹Ø¯ Ø§Ø² Ûµ Ø§Ù…ØªÛŒØ§Ø²)

  // 1. Ù…Ø¯ÛŒØ±ÛŒØª Ø²Ù…Ø§Ù†â€ŒØ¨Ù†Ø¯ÛŒ
  // Ø§Ú¯Ø± Ø¯Ø± Ø­Ø§Ù„ Ø¨Ø§Ø±Ø´ Ù‡Ø³ØªÛŒÙ…
  if (stormDuration > 0) {
    stormDuration--;
    // ØªÙˆÙ„ÛŒØ¯ Ø³Ù†Ú¯ (ØªØ±Ø§Ú©Ù… Ø¨Ø§Ù„Ø§ Ø¨Ø±Ø§ÛŒ Û² Ø«Ø§Ù†ÛŒÙ‡)
    if (Math.random() < 0.08) { // Ø´Ø§Ù†Ø³ Ø¨Ø§Ø±Ø´ Ø²ÛŒØ§Ø¯ (Û²ÛµÙª Ø¯Ø± Ù‡Ø± ÙØ±ÛŒÙ…)
      fallingObjects.push({
        x: 40 + Math.random() * (canvas.width - 80), // ÙÙ‚Ø· ÙˆØ³Ø· ØµÙØ­Ù‡
        y: player.y - canvas.height, // Ø§Ø² Ø¨Ø§Ù„Ø§ Ù…ÛŒâ€ŒØ§ÙØªØ¯
        radius: 20 + Math.random() * 10, // Ø³Ù†Ú¯â€ŒÙ‡Ø§ÛŒ Ø¨Ø²Ø±Ú¯
        vy: 10, 
        color: "#f1c40f"
      });
    }
  } 
  // Ø§Ú¯Ø± Ø¨Ø§Ø±Ø´ Ù†ÛŒØ³ØªØŒ ØªØ§ÛŒÙ…Ø± Ø±Ø§ Ú©Ù… Ú©Ù†
  else {
    stormTimer--;
    
    // ÙˆÙ‚ØªÛŒ ØªØ§ÛŒÙ…Ø± Ø¨Ù‡ 0 Ø±Ø³ÛŒØ¯ØŒ ÛŒØ¹Ù†ÛŒ Ù‡Ø´Ø¯Ø§Ø± Û³ Ø«Ø§Ù†ÛŒÙ‡â€ŒØ§ÛŒ ØªÙ…Ø§Ù… Ø´Ø¯Ù‡ -> Ø´Ø±ÙˆØ¹ Ø·ÙˆÙØ§Ù†
    if (stormTimer <= 0) {
        stormDuration = 90; // Ù…Ø¯Øª Ø¨Ø§Ø±Ø´: Û² Ø«Ø§Ù†ÛŒÙ‡ (120 ÙØ±ÛŒÙ…)
        stormTimer = 1500;   // ØªÙ†Ø¸ÛŒÙ… Ø²Ù…Ø§Ù† Ø¨Ø±Ø§ÛŒ Ø·ÙˆÙØ§Ù† Ø¨Ø¹Ø¯ÛŒ (Ù…Ø«Ù„Ø§Ù‹ Û²Ûµ Ø«Ø§Ù†ÛŒÙ‡ Ø¨Ø¹Ø¯)
    }
  }

  // 2. Ù†Ù…Ø§ÛŒØ´ Ù‡Ø´Ø¯Ø§Ø± (ÙÙ‚Ø· Ø¯Ø± Û³ Ø«Ø§Ù†ÛŒÙ‡ Ø¢Ø®Ø±Ù ØªØ§ÛŒÙ…Ø±)
  // 180 ÙØ±ÛŒÙ… = 3 Ø«Ø§Ù†ÛŒÙ‡
  if (stormTimer > 0 && stormTimer <= 180) {
    ctx.save();
    
    // Ø§Ù„Ù) ÙˆÛŒÙ†ÛŒØª Ù‚Ø±Ù…Ø² (Red Vignette)
    // ÛŒÚ© Ú¯Ø±Ø§Ø¯ÛŒØ§Ù†Øª Ú©Ù‡ ÙˆØ³Ø·Ø´ Ø´ÙØ§Ù Ùˆ Ø¯ÙˆØ±Ø´ Ù‚Ø±Ù…Ø² Ø§Ø³Øª
    const gradient = ctx.createRadialGradient(
        canvas.width / 2, canvas.height / 2, canvas.height / 3, // Ø¯Ø§ÛŒØ±Ù‡ Ø¯Ø§Ø®Ù„ÛŒ
        canvas.width / 2, canvas.height / 2, canvas.height      // Ø¯Ø§ÛŒØ±Ù‡ Ø¨ÛŒØ±ÙˆÙ†ÛŒ
    );
    gradient.addColorStop(0, "rgba(255, 0, 0, 0)"); // ÙˆØ³Ø· Ø´ÙØ§Ù
    gradient.addColorStop(1, "rgba(200, 0, 0, 0.6)"); // Ø¯ÙˆØ± Ù‚Ø±Ù…Ø² ØªÛŒØ±Ù‡
    
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Ø¨) Ù†ÙˆØ§Ø± Ø³ÛŒØ§Ù‡ Ù‡Ø´Ø¯Ø§Ø± (ÙˆØ³Ø· ØµÙØ­Ù‡)
    const barHeight = 100;
    const centerY = canvas.height / 2 - barHeight / 2;
    
    ctx.fillStyle = "rgba(0, 0, 0, 0.85)"; // Ù†ÙˆØ§Ø± Ø³ÛŒØ§Ù‡ Ù¾Ø±Ø±Ù†Ú¯
    ctx.fillRect(0, centerY, canvas.width, barHeight);
    
    // Ø¬) Ø®Ø·ÙˆØ· Ù‚Ø±Ù…Ø² Ø¨Ø§Ù„Ø§ Ùˆ Ù¾Ø§ÛŒÛŒÙ† Ù†ÙˆØ§Ø±
    ctx.fillStyle = "#e74c3c";
    ctx.fillRect(0, centerY, canvas.width, 5);
    ctx.fillRect(0, centerY + barHeight - 5, canvas.width, 5);

    // Ø¯) Ù…ØªÙ† Ø¨Ø²Ø±Ú¯ Ù‡Ø´Ø¯Ø§Ø±
    ctx.font = "bold 40px Tahoma";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    
    // Ù…ØªÙ† Ú†Ø´Ù…Ú©â€ŒØ²Ù† (Ø³ÙÛŒØ¯ Ùˆ Ø²Ø±Ø¯)
    const pulse = Math.floor(Date.now() / 100) % 2;
    ctx.fillStyle = pulse ? "#ffff00" : "#ffffff";
    
    // Ù†Ù…Ø§ÛŒØ´ Ø«Ø§Ù†ÛŒÙ‡ Ø´Ù…Ø§Ø± Ù…Ø¹Ú©ÙˆØ³ (3... 2... 1...)
    const secondsLeft = Math.ceil(stormTimer / 60);
    ctx.fillText(`âš ï¸ Ø®Ø·Ø± Ø±ÛŒØ²Ø´ Ø³Ù†Ú¯ (${secondsLeft}) âš ï¸`, canvas.width / 2, canvas.height / 2);

    ctx.restore();
  }
}function addNewGate() {
  const prevGateY = lastGateY;
  const gap = minGateDistance + Math.random() * (maxGateDistance - minGateDistance);
  const nextY = lastGateY - gap;
  gates.push(createGate(nextY));
  spawnObstaclesBetween(nextY + 350, prevGateY - 350);
  lastGateY = nextY;
}

function reset() {
  score = 0; shake = 0; flashAlpha = 0; activeLaser = null;
  stormTimer = 1000; stormDuration = 0;
  currentGroundY = canvas.height - 300;
  player = { x: canvas.width / 2, y: currentGroundY - 35, radius: 60, vx: 0, vy: 0, alive: true, onGround: true,facing: 1 };
  gates = []; obstacles = []; fallingObjects = [];
  lastGateY = -150;
  gates.push(createGate(lastGateY));
  addNewGate();
}

function triggerGameOver() {
  if (gameState === 'gameover') return;
  gameState = 'gameover';
  shake = 15; flashAlpha = 0.5; player.alive = false;
  if (score > highScore) {
    highScore = score;
    localStorage.setItem("plantJumpBest", highScore);
  }
  let lastGate = gates.find(g => g.y < player.y + 200) || gates[0];
  setTimeout(() => {
    document.getElementById("final-score").innerText = "Ø§Ù…ØªÛŒØ§Ø²: " + score;
    document.getElementById("best-score").innerText = "Ø¨Ù‡ØªØ±ÛŒÙ† Ø±Ú©ÙˆØ±Ø¯: " + highScore;
    document.getElementById("edu-info").innerText = "Ø¯Ø§Ù†Ø³ØªÙ†ÛŒ Ø¹Ù„Ù…ÛŒ: " + lastGate.quiz.desc;
    uiLayer.style.display = "flex";
  }, 500);
}

function restartGame() {
  uiLayer.style.display = "none";
  gameState = 'playing';
  reset();
}

const handleInput = (inputX) => {
  const guide = document.getElementById("start-guide");
  if (guide) guide.remove();
  if(gameState !== 'playing' || !player.alive) return;
  player.vy = jumpForce;
  player.vx = inputX < canvas.width / 2 ? -8 : 8;
  player.onGround = false;
};
canvas.addEventListener("touchstart", e => handleInput(e.touches[0].clientX));
window.addEventListener("mousedown", e => handleInput(e.clientX));

function gameLoop() {
  ctx.save();
const wallWidth = 30; 
  const blockSize = 84;
  if (shake > 0) {
    ctx.translate((Math.random() - 0.5) * shake, (Math.random() - 0.5) * shake);
    shake *= 0.9;
  }
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // ------------------------------------

  // ------------------------------------
  

  if (player.alive) {
    player.vy += gravity;
    player.y += player.vy;
    player.x += player.vx;
    player.vx *= 0.98;

    if (player.vy > 0 && currentGroundY < canvas.height + 50 && player.y + player.radius > currentGroundY) {
      player.y = currentGroundY - player.radius;
      player.vy = 0; player.onGround = true;
    }

    if (player.y < canvas.height * 0.55) {
      let diff = (canvas.height * 0.55 - player.y) * 0.2;
      player.y += diff; currentGroundY += diff; lastGateY += diff;      
      gates.forEach(g => g.y += diff);
      obstacles.forEach(o => o.y += diff);
      fallingObjects.forEach(f => f.y += diff);
      if(activeLaser) activeLaser.y += diff;
    }

    if (gates.length > 0 && gates[0].y > canvas.height + 300) {
      gates.shift();
      addNewGate();
    }
  
  }

  obstacles.forEach((obs, index) => {
    if (obs.vx !== 0) {
      obs.x += obs.vx;
      if (obs.x + obs.w > canvas.width - wallWidth || obs.x < wallWidth) obs.vx *= -1;
    }
    ctx.fillStyle = obs.color;
    ctx.fillRect(obs.x, obs.y, obs.w, obs.h);
    if (player.alive && player.x + 20 > obs.x && player.x - 20 < obs.x + obs.w && player.y + 20 > obs.y && player.y - 20 < obs.y + obs.h) triggerGameOver();
    if (obs.y > canvas.height + 400) obstacles.splice(index, 1);
  });

  

ctx.save(); // Ø°Ø®ÛŒØ±Ù‡ ÙˆØ¶Ø¹ÛŒØª Ú©Ù„ÛŒ Ø¨Ø±Ø§ÛŒ Ø§ÛŒØ¬Ø§Ø¯ Ù…Ø­Ø¯ÙˆØ¯Ù‡ Ø¨Ø±Ø´
  ctx.beginPath();
  // Ù…Ø­Ø¯ÙˆØ¯Ù‡ Ø¨Ø±Ø´: Ø§Ø² Ù„Ø¨Ù‡ Ø¯ÛŒÙˆØ§Ø± Ú†Ù¾ ØªØ§ Ù„Ø¨Ù‡ Ø¯ÛŒÙˆØ§Ø± Ø±Ø§Ø³Øª
  ctx.rect(wallWidth, 0, canvas.width - (wallWidth * 2), canvas.height);
  ctx.clip(); // Ø§Ø² Ø§ÛŒÙ†Ø¬Ø§ Ø¨Ù‡ Ø¨Ø¹Ø¯ Ù‡Ø± Ú†Ù‡ Ø±Ø³Ù… Ø´ÙˆØ¯ ÙÙ‚Ø· Ø¯Ø± Ø§ÛŒÙ† Ù…Ø³ØªØ·ÛŒÙ„ Ø¯ÛŒØ¯Ù‡ Ù…ÛŒâ€ŒØ´ÙˆØ¯

  gates.forEach(gate => {
    const sideMargin = 56; // ÙØ§ØµÙ„Ù‡ Ø§Ø² Ø¨ØºÙ„ ØµÙØ­Ù‡ (Ø­Ø§Ø´ÛŒÙ‡)
    // Ø¹Ø±Ø¶ Ù…ÙÛŒØ¯ Ø¨Ø§Ø²ÛŒ (Ú©Ù„ ØµÙØ­Ù‡ Ù…Ù†Ù‡Ø§ÛŒ Ø¯Ùˆ Ø­Ø§Ø´ÛŒÙ‡ Ú†Ù¾ Ùˆ Ø±Ø§Ø³Øª)
    const playWidth = canvas.width - (sideMargin * 2);

    // Ø­Ø±Ú©Øª Ø§ÙÙ‚ÛŒ Ú¯ÛŒØªâ€ŒÙ‡Ø§ Ø¨Ø± Ø§Ø³Ø§Ø³ Ø¹Ø±Ø¶ Ù…ÙÛŒØ¯
    if (gate.vx !== 0) {
      gate.x += gate.vx;
      // Ù†Ú©ØªÙ‡ Ù…Ù‡Ù…: Ø±Ù¾ÛŒÙ†Ú¯ Ø¨Ø§ÛŒØ¯ Ø¨Ø± Ø§Ø³Ø§Ø³ playWidth Ø¨Ø§Ø´Ø¯ Ù†Ù‡ canvas.width
      if (gate.x > playWidth) gate.x -= playWidth;
      if (gate.x < -playWidth) gate.x += playWidth;
    }
   
    const n = gate.options.length;
    const w = playWidth / n; // Ø¹Ø±Ø¶ Ù‡Ø± Ø³Ù„ÙˆÙ„ Ø¨Ø± Ø§Ø³Ø§Ø³ ÙØ¶Ø§ÛŒ Ù…ÙÛŒØ¯
    const pillarH = 80; 

    // Ø±Ø³Ù… Ø¯Ø± Ø³Ù‡ Ù…ÙˆÙ‚Ø¹ÛŒØª Ø¨Ø±Ø§ÛŒ Ø§ÛŒØ¬Ø§Ø¯ Ø­Ø§Ù„Øª Ø¨ÛŒâ€ŒÙ†Ù‡Ø§ÛŒØª
    // Ø¢ÙØ³Øªâ€ŒÙ‡Ø§ Ø¨Ø± Ø§Ø³Ø§Ø³ playWidth Ù…Ø­Ø§Ø³Ø¨Ù‡ Ù…ÛŒâ€ŒØ´ÙˆÙ†Ø¯
    [gate.x, gate.x + playWidth, gate.x - playWidth].forEach(off => {
      
      // *** ØªØºÛŒÛŒØ± Ú©Ù„ÛŒØ¯ÛŒ Ø¨Ø±Ø§ÛŒ Ø±ÙØ¹ Ø¯Ùˆ Ø³ØªÙˆÙ†Ù‡ Ø´Ø¯Ù† ***
      // Ø­Ù„Ù‚Ù‡ Ø¨Ø§ÛŒØ¯ i < n Ø¨Ø§Ø´Ø¯ (Ù†Ù‡ i <= n). 
      // Ø¯ÛŒÙˆØ§Ø± Ø¢Ø®Ø±Ù Ø§ÛŒÙ† Ù‚Ø·Ø¹Ù‡ ØªÙˆØ³Ø· Ø¯ÛŒÙˆØ§Ø± Ø§ÙˆÙ„Ù Ù‚Ø·Ø¹Ù‡â€ŒÛŒ Ø¨Ø¹Ø¯ÛŒ ØªØ§Ù…ÛŒÙ† Ù…ÛŒâ€ŒØ´ÙˆØ¯.
     // --- Ø­Ù„Ù‚Ù‡ Ø±Ø³Ù… Ø³ØªÙˆÙ†â€ŒÙ‡Ø§ÛŒ Ù¾ÛŒØ´Ø±ÙØªÙ‡ ---
        for (let i = 0; i < n; i++) {
            const pillarW = 50; 
            const pillarX = off + sideMargin + (i * w) - pillarW / 2;
            
            // ÙÙ‚Ø· Ø§Ú¯Ø± Ø¯Ø± Ø¯ÛŒØ¯ Ø§Ø³Øª Ø±Ø³Ù… Ú©Ù†
            if (pillarX > -100 && pillarX < canvas.width + 100) {
                
                // 1. Ø¨Ø¯Ù†Ù‡ Ø§ØµÙ„ÛŒ Ø³ØªÙˆÙ† (ØªÛŒØ±Ù‡â€ŒØªØ± Ø¨Ø±Ø§ÛŒ Ø¹Ù…Ù‚)
                ctx.fillStyle = "#34495e"; 
                ctx.shadowBlur = 0;
                ctx.fillRect(pillarX, gate.y, pillarW, pillarH);

                // 2. Ø³Ø±Ø³ØªÙˆÙ† (Cap) - Ú©Ù…ÛŒ Ù¾Ù‡Ù†â€ŒØªØ± Ø§Ø² Ø³ØªÙˆÙ†
                ctx.fillStyle = "#2c3e50"; // Ø±Ù†Ú¯ Ù…ØªÙØ§ÙˆØª
                ctx.fillRect(pillarX - 5, gate.y, pillarW + 10, 15);

                // 3. Ù¾Ø§Ø³ØªÙˆÙ† (Base) - Ú©Ù…ÛŒ Ù¾Ù‡Ù†â€ŒØªØ± Ø¯Ø± Ù¾Ø§ÛŒÛŒÙ†
                ctx.fillRect(pillarX - 5, gate.y + pillarH - 15, pillarW + 10, 15);

                // 4. Ø¬Ø²Ø¦ÛŒØ§Øª Ø¯Ø§Ø®Ù„ÛŒ (Ø®Ø·ÙˆØ· Ø¹Ù…ÙˆØ¯ÛŒ Ø¨Ø±Ø§ÛŒ Ø­Ø³ ÙÙ„Ø²ÛŒ/Ø³Ù†Ú¯ÛŒ)
                ctx.fillStyle = "rgba(0,0,0,0.2)";
                ctx.fillRect(pillarX + 10, gate.y + 15, 5, pillarH - 30);
                ctx.fillRect(pillarX + pillarW - 15, gate.y + 15, 5, pillarH - 30);

                // 5. Ù†Ø§Ø²Ù„ Ù„ÛŒØ²Ø± (Emitter)
                // Ø§Ú¯Ø± Ø§ÛŒÙ† Ø³ØªÙˆÙ†ØŒ Ø³ØªÙˆÙ†ÛŒ Ø§Ø³Øª Ú©Ù‡ Ù„ÛŒØ²Ø± Ø¨Ø§ÛŒØ¯ Ø§Ø² Ø³Ù…Øª Ø±Ø§Ø³ØªØ´ Ø¨ÛŒØ±ÙˆÙ† Ø¨ÛŒØ§ÛŒØ¯
                // ÛŒØ§ Ø³ØªÙˆÙ†ÛŒ Ø§Ø³Øª Ú©Ù‡ Ù„ÛŒØ²Ø± Ø¨Ø§ÛŒØ¯ Ø¨Ù‡ Ø³Ù…Øª Ú†Ù¾Ø´ Ø¨Ø±Ø®ÙˆØ±Ø¯ Ú©Ù†Ø¯
                // ÛŒÚ© Ø¨Ø±Ø¬Ø³ØªÚ¯ÛŒ Ú©ÙˆÚ†Ú© Ù‚Ø±Ù…Ø² ÛŒØ§ Ø²Ø±Ø¯ Ø±ÙˆÛŒ Ø¨Ø¯Ù†Ù‡ Ø¨Ú©Ø´ÛŒÙ…
                ctx.fillStyle = "#c0392b";
                // Ø³Ù…Øª Ø±Ø§Ø³Øª Ø³ØªÙˆÙ† (Ø¨Ø±Ø§ÛŒ Ø´Ø±ÙˆØ¹ Ù„ÛŒØ²Ø± Ø¨Ø¹Ø¯ÛŒ)
                ctx.fillRect(pillarX + pillarW, gate.y + pillarH/2 - 5, 4, 10);
                // Ø³Ù…Øª Ú†Ù¾ Ø³ØªÙˆÙ† (Ø¨Ø±Ø§ÛŒ Ù¾Ø§ÛŒØ§Ù† Ù„ÛŒØ²Ø± Ù‚Ø¨Ù„ÛŒ)
                ctx.fillRect(pillarX - 4, gate.y + pillarH/2 - 5, 4, 10);


ctx.save();
            
            // 1. ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ø§Ø¨Ø¹Ø§Ø¯
            const beamBaseX = pillarX + pillarW / 2; 
            const beamBaseY = gate.y; 
            const beamH = pillarH * 5; // Ø§Ø±ØªÙØ§Ø¹ Ø¨Ù„Ù†Ø¯
            const beamW = pillarW * 0.8; // Ø¹Ø±Ø¶ Ø«Ø§Ø¨Øª

            // 2. ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ù†ÙˆØ± (Ø¨Ø¯ÙˆÙ† Ø§Ù†ÛŒÙ…ÛŒØ´Ù†)
            // Ø­Ø§Ù„Øª ØªØ±Ú©ÛŒØ¨ÛŒ Ø¨Ø±Ø§ÛŒ Ø¯Ø±Ø®Ø´Ø´ Ø±ÙˆÛŒ Ù¾Ø³â€ŒØ²Ù…ÛŒÙ†Ù‡ ØªÛŒØ±Ù‡
            ctx.globalCompositeOperation = "screen"; 

            // 3. Ú¯Ø±Ø§Ø¯ÛŒØ§Ù†Øª Ù†ÙˆØ± (Ø§Ø² Ù¾Ø§ÛŒÛŒÙ† Ù¾Ø±Ø±Ù†Ú¯ ØªØ§ Ø¨Ø§Ù„Ø§ Ù…Ø­Ùˆ)
            const gradient = ctx.createLinearGradient(beamBaseX, beamBaseY, beamBaseX, beamBaseY - beamH);
            
            // Ù¾Ø§ÛŒÛŒÙ†: Ø³ÙÛŒØ¯/Ø¢Ø¨ÛŒ Ø±ÙˆØ´Ù† (Ù…Ù†Ø¨Ø¹ Ù†ÙˆØ±) - Ø«Ø§Ø¨Øª
            gradient.addColorStop(0, "rgba(200, 255, 255, 0.6)");
            // ÙˆØ³Ø·: ÙÛŒØ±ÙˆØ²Ù‡â€ŒØ§ÛŒ Ù†Ø¦ÙˆÙ†ÛŒ - Ø«Ø§Ø¨Øª
            gradient.addColorStop(0.3, "rgba(0, 243, 255, 0.4)");
            // Ø¨Ø§Ù„Ø§: Ù…Ø­Ùˆ Ú©Ø§Ù…Ù„
            gradient.addColorStop(1, "rgba(0, 243, 255, 0)");

            ctx.fillStyle = gradient;
            
            // 4. Ø¯Ø±Ø®Ø´Ø´ Ø¨ÛŒØ±ÙˆÙ†ÛŒ Ø«Ø§Ø¨Øª (Glow)
            ctx.shadowColor = "cyan";
            ctx.shadowBlur = 15; // Ø¯Ø±Ø®Ø´Ø´ Ù…Ù„Ø§ÛŒÙ… Ùˆ Ø«Ø§Ø¨Øª

            // 5. Ø±Ø³Ù… Ù¾Ø±ØªÙˆ Ù†ÙˆØ± (Ù…Ø³ØªØ·ÛŒÙ„ Ø°ÙˆØ²Ù†Ù‚Ù‡â€ŒØ§ÛŒ Ø´Ú©Ù„)
            ctx.beginPath();
            ctx.moveTo(beamBaseX - beamW / 2, beamBaseY); // Ù¾Ø§ÛŒÛŒÙ† Ú†Ù¾
            ctx.lineTo(beamBaseX - (beamW * 0.8) / 2, beamBaseY - beamH); // Ø¨Ø§Ù„Ø§ Ú†Ù¾ (Ú©Ù…ÛŒ Ø¬Ù…Ø¹â€ŒØªØ±)
            ctx.lineTo(beamBaseX + (beamW * 0.8) / 2, beamBaseY - beamH); // Ø¨Ø§Ù„Ø§ Ø±Ø§Ø³Øª
            ctx.lineTo(beamBaseX + beamW / 2, beamBaseY); // Ù¾Ø§ÛŒÛŒÙ† Ø±Ø§Ø³Øª
            ctx.fill();


            ctx.restore();             // Ù…Ù†Ø·Ù‚ Ø¨Ø±Ø®ÙˆØ±Ø¯ (Ù‡Ù…Ø§Ù† Ú©Ø¯ Ù‚Ø¨Ù„ÛŒ Ø¨Ø¯ÙˆÙ† ØªØºÛŒÛŒØ±)
                if (player.alive && 
                    player.x + 55 > pillarX && player.x - 55 < pillarX + pillarW &&
                    player.y + 55 > gate.y && player.y - 55 < gate.y + pillarH) {
                    
                    let overlapLeft = (player.x + 55) - pillarX;
                    let overlapRight = (pillarX + pillarW) - (player.x - 55);
                    let overlapTop = (player.y + 55) - gate.y;
                    let overlapBottom = (gate.y + pillarH) - (player.y - 55);
                    let minOverlap = Math.min(overlapLeft, overlapRight, overlapTop, overlapBottom);

                    if (minOverlap === overlapTop && player.vy > 0) {
                        player.y = gate.y - 55; player.vy = 0; player.onGround = true;
                    } 
                    else if (minOverlap === overlapBottom && player.vy < 0) {
                        player.y = gate.y + pillarH + 55; player.vy *= -0.5;
                    } 
                    else if (minOverlap === overlapLeft) {
                        player.x = pillarX - 55; player.vx = 0;
                    } 
                    else if (minOverlap === overlapRight) {
                        player.x = pillarX + pillarW + 55; player.vx = 0;
                    }
                }
            }
        }

        
      // ØªÙ†Ø¸ÛŒÙ… Ù…ÙˆÙ‚Ø¹ÛŒØª Ú©Ø§Ø±Øªâ€ŒÙ‡Ø§
     gate.options.forEach((txt, i) => {
        const cardW = w * 0.82;
        const cardH = cardW;
        
             const hoverDistance = 40;
             const cardY = gate.y - cardH + hoverDistance;

        // Ù…Ø­Ø§Ø³Ø¨Ù‡ Ù…Ø±Ú©Ø² Ù‡Ø± Ø¨Ø®Ø´ Ø¨Ø±Ø§ÛŒ Ù‚Ø±Ø§Ø±Ú¯ÛŒØ±ÛŒ Ú©Ø§Ø±Øª
        // Ù…ØªØºÛŒØ± off Ø´Ø§Ù…Ù„ Ø³Ù‡ Ø­Ø§Ù„Øª (gate.x Ùˆ gate.x + playWidth Ùˆ gate.x - playWidth) Ø§Ø³Øª
        const cardX = off + sideMargin + (i * w) + (w - cardW) / 2;
        const centerX = cardX + cardW / 2;
        
        const imgPath = gate.quiz.images[txt];
        const imgObj = imageAssets[imgPath];
        
        // Ú†Ú© Ú©Ø±Ø¯Ù† Ù„ÙˆØ¯ Ø´Ø¯Ù† ØªØµÙˆÛŒØ±
        if (imgObj && imgObj.complete && imgObj.naturalWidth !== 0) {
          // Ø±Ø³Ù… ØªØµÙˆÛŒØ± Ø¯Ø± Ù‡Ø± Ø³Ù‡ Ø¢ÙØ³Øª (Ú†Ù¾ØŒ ÙˆØ³Ø·ØŒ Ø±Ø§Ø³Øª)
          ctx.drawImage(imgObj, cardX, cardY, cardW, cardH);
        } else {
          // Ø§Ú¯Ø± Ù‡Ù†ÙˆØ² Ù„ÙˆØ¯ Ù†Ø´Ø¯Ù‡ØŒ ÛŒÚ© Ú©Ø§Ø¯Ø± Ø³ÙÛŒØ¯ Ø¨Ø§ Ù…ØªÙ† Ù†Ø´Ø§Ù† Ø¨Ø¯Ù‡ ØªØ§ Ù¾Ø±Ø´ ØªØµÙˆÛŒØ±ÛŒ Ù†Ø¯Ø§Ø´ØªÙ‡ Ø¨Ø§Ø´ÛŒÙ…
          ctx.fillStyle = "white"; 
          ctx.fillRect(cardX, cardY, cardW, cardH);
          ctx.fillStyle = "black"; 
          ctx.font = "bold 14px Tahoma"; 
          ctx.textAlign = "center";
          ctx.fillText(txt, cardX + cardW/2, cardY + cardH/2);
        }
      });
    });

    // Ø§ØµÙ„Ø§Ø­ Ù…Ù†Ø·Ù‚ Ù„ÛŒØ²Ø± (Ø¨Ø§ Ø¯Ø± Ù†Ø¸Ø± Ú¯Ø±ÙØªÙ† Ø­Ø§Ø´ÛŒÙ‡ Ùˆ Ø±Ù¾ÛŒÙ†Ú¯)
    if (player.alive && player.y > gate.y && player.y < gate.y + pillarH) {
      // Ù†Ø±Ù…Ø§Ù„â€ŒØ³Ø§Ø²ÛŒ Ù…ÙˆÙ‚Ø¹ÛŒØª Ø¨Ø§Ø²ÛŒÚ©Ù† Ù†Ø³Ø¨Øª Ø¨Ù‡ ÙØ¶Ø§ÛŒ Ø¨Ø§Ø²ÛŒ (Ø¨Ø¯ÙˆÙ† Ø­Ø§Ø´ÛŒÙ‡)
      let relativePlayerX = player.x - sideMargin; 
      
      // Ù…Ø­Ø§Ø³Ø¨Ù‡ Ù…ÙˆÙ‚Ø¹ÛŒØª Ù†Ø³Ø¨ÛŒ Ø¯Ø± Ø³ÛŒØ³ØªÙ… Ú†Ø±Ø®Ø´ÛŒ
      let relX = (relativePlayerX - gate.x) % playWidth;
      if (relX < 0) relX += playWidth;

      // Ø§Ú¯Ø± Ø¨Ø§Ø²ÛŒÚ©Ù† Ø¯Ø§Ø®Ù„ Ø­Ø§Ø´ÛŒÙ‡â€ŒÙ‡Ø§ Ø±ÙØªÙ‡ Ø¨Ø§Ø´Ø¯ (Ø®Ø§Ø±Ø¬ Ø§Ø² Ø¨Ø§Ø²ÛŒ)ØŒ Ù†Ø¨Ø§ÛŒØ¯ Ø¨Ø³ÙˆØ²Ø¯ (ÛŒØ§ Ø¨Ø§ Ø¯ÛŒÙˆØ§Ø± Ø¨Ø±Ø®ÙˆØ±Ø¯ Ú©Ø±Ø¯Ù‡)
      if (player.x > sideMargin && player.x < canvas.width - sideMargin) {
          let optIdx = Math.floor(relX / w);
          let innerX = relX % w;
          let laserMargin = 15; 
          
          if (innerX > laserMargin && innerX < w - laserMargin) {
            let selectedOption = gate.options[optIdx];
            if (selectedOption && !gate.quiz.correct.includes(selectedOption)) {
              
              // Ù¾ÛŒØ¯Ø§ Ú©Ø±Ø¯Ù† Ø¨Ù‡ØªØ±ÛŒÙ† X Ø¨Ø±Ø§ÛŒ Ø±Ø³Ù… Ù„ÛŒØ²Ø± Ú©Ù‡ Ù†Ø²Ø¯ÛŒÚ© Ø¨Ø§Ø²ÛŒÚ©Ù† Ø¨Ø§Ø´Ø¯
              let bestLaserXStart = 0;
              let minDistance = 99999;
              
              [gate.x, gate.x + playWidth, gate.x - playWidth].forEach(off => {
                  let laserStartX = off + sideMargin + (optIdx * w) + laserMargin;
                  let dist = Math.abs(player.x - (laserStartX + (w/2)));
                  if(dist < minDistance) {
                      minDistance = dist;
                      bestLaserXStart = laserStartX;
                  }
              });

              activeLaser = { 
                x1: bestLaserXStart, 
                x2: bestLaserXStart + w - (laserMargin * 2), 
                y: gate.y + (pillarH / 2), 
                life: 10 
              };
              triggerGameOver();
            }
          }
      }
    }
    if (player.alive && player.y < gate.y && !gate.scored) { score++; gate.scored = true; }
  });

fallingObjects.forEach((f, index) => {
    f.vy += 0.1; f.y += f.vy;
    ctx.beginPath(); ctx.arc(f.x, f.y, f.radius, 0, Math.PI * 2);
    ctx.fillStyle = f.color; ctx.fill();

    let hitSomething = false;
    obstacles.forEach(obs => {
      if (f.x + f.radius > obs.x && f.x - f.radius < obs.x + obs.w && f.y + f.radius > obs.y && f.y - f.radius < obs.y + obs.h) hitSomething = true;
    });



    gates.forEach(gate => {
      const n = gate.options.length;
      const w = canvas.width / n;
      [gate.x, gate.x + canvas.width, gate.x - canvas.width].forEach(off => {
        for (let i = 0; i <= n; i++) {
          const pillarW = 50; 
          const pillarX = off + (i * w) - pillarW / 2;
          const pillarH = 80;
          if (f.x + f.radius > pillarX && f.x - f.radius < pillarX + pillarW && 
              f.y + f.radius > gate.y && f.y - f.radius < gate.y + pillarH) {
            hitSomething = true;
          }
        }
      });
    });

    if (hitSomething) { 
      fallingObjects.splice(index, 1); 
      return; 
    }

    const dx = player.x - f.x, dy = player.y - f.y;
    if (player.alive && Math.sqrt(dx*dx + dy*dy) < player.radius + f.radius) triggerGameOver();
    if (f.y > canvas.height + 500) fallingObjects.splice(index, 1);
  });
  manageFallingStorm();
ctx.restore();

  if (activeLaser && activeLaser.life > 0) {
    ctx.save();
    ctx.strokeStyle = "red"; ctx.lineWidth = 8;
    ctx.shadowBlur = 20; ctx.shadowColor = "red";
    ctx.beginPath();
    ctx.moveTo(activeLaser.x1, activeLaser.y);
    ctx.lineTo(activeLaser.x2, activeLaser.y);
    ctx.stroke();
    ctx.strokeStyle = "white"; ctx.lineWidth = 2; ctx.stroke();
    ctx.restore();
    activeLaser.life--;
  }

  ctx.fillStyle = "#1a1a1a";
  ctx.fillRect(0, 0, canvas.width, 100);
  
  // Ø¨Ø±Ø±Ø³ÛŒ Ø¨Ø±Ø®ÙˆØ±Ø¯ Ø¨Ø§ Ø¨Ù„ÙˆÚ©â€ŒÙ‡Ø§ÛŒ Ø¯ÛŒÙˆØ§Ø±ÛŒ Ùˆ Ø³Ù‚ÙˆØ·
// Ø§ØµÙ„Ø§Ø­ Ø´Ø±Ø· Ø¨Ø§Ø®Øª Ø¨Ø±Ø§ÛŒ Ø¨Ø±Ø®ÙˆØ±Ø¯ Ø¨Ø§ Ø¯ÛŒÙˆØ§Ø±Ù‡â€ŒÙ‡Ø§ÛŒ Ø¬Ø¯ÛŒØ¯
 // Ø§ØµÙ„Ø§Ø­ Ø´Ø±Ø· Ø¨Ø§Ø®Øª Ø¨Ø±Ø§ÛŒ Ø¨Ø±Ø®ÙˆØ±Ø¯ Ø¨Ø§ Ø¯ÛŒÙˆØ§Ø±Ù‡â€ŒÙ‡Ø§ÛŒ Ø¬Ø¯ÛŒØ¯
  if (player.alive) {
    // Ø¨Ø±Ø®ÙˆØ±Ø¯ Ø¨Ø§ Ø¨Ù„ÙˆÚ©â€ŒÙ‡Ø§ÛŒ Ú†Ù¾ Ùˆ Ø±Ø§Ø³Øª
    if (player.x - player.radius < wallWidth || player.x + player.radius > canvas.width - wallWidth) {
        triggerGameOver();
    }
    // Ø´Ø±Ø· Ø®Ø±ÙˆØ¬ Ø§Ø² Ø¨Ø§Ù„Ø§ ÛŒØ§ Ù¾Ø§ÛŒÛŒÙ† (Ú©Ø¯ Ù‚Ø¨Ù„ÛŒ Ø´Ù…Ø§)
    if (player.x < 0 || player.x > canvas.width || (player.y - 25 > canvas.height && !player.onGround)) {
        triggerGameOver();
    }
  }
  // --- Ø¨Ø®Ø´ Ø¬Ø¯ÛŒØ¯: Ø±Ø³Ù… Ø§Ø³Ù¾Ø±Ø§ÛŒØª Ø¨Ù‡ Ø¬Ø§ÛŒ Ø¯Ø§ÛŒØ±Ù‡ ---
  // --- Ø±Ø³Ù… Ø§Ø³Ù¾Ø±Ø§ÛŒØª ÙˆØ§Ú©Ù†Ø´ÛŒ (Ø¨Ø¯ÙˆÙ† Ø§Ù†ÛŒÙ…ÛŒØ´Ù† Ø®ÙˆØ¯Ú©Ø§Ø±) ---
 // --- Ø±Ø³Ù… Ø§Ø³Ù¾Ø±Ø§ÛŒØª ÙˆØ§Ú©Ù†Ø´ÛŒ ---
  if (player.alive) {
    ctx.save();
    
    // Ø§Ù†ØªØ®Ø§Ø¨ ÙØ±ÛŒÙ…: Ø§Ú¯Ø± Ø±ÙˆÛŒ Ø²Ù…ÛŒÙ† Ù†ÛŒØ³Øª ÙØ±ÛŒÙ… Û±ØŒ ÙˆÚ¯Ø±Ù†Ù‡ ÙØ±ÛŒÙ… Û°
    let currentFrame = player.onGround ? 0 : 1; 

    // Ø§Ù†ØªÙ‚Ø§Ù„ Ø¨Ù‡ Ù…ÙˆÙ‚Ø¹ÛŒØª Ø¨Ø§Ø²ÛŒÚ©Ù†
    ctx.translate(player.x, player.y);

    // --- ØªØºÛŒÛŒØ± Ù…Ù‡Ù…: Ø¢Ù¾Ø¯ÛŒØª Ú©Ø±Ø¯Ù† Ø¬Ù‡Øª ÙÙ‚Ø· Ø§Ú¯Ø± Ø³Ø±Ø¹Øª Ø²ÛŒØ§Ø¯ Ø§Ø³Øª ---
    // Ø§Ú¯Ø± Ø³Ø±Ø¹Øª Ø®ÛŒÙ„ÛŒ Ú©Ù… ÛŒØ§ ØµÙØ± Ø§Ø³ØªØŒ Ø¯Ø³Øª Ø¨Ù‡ facing Ù†Ø²Ù† ØªØ§ Ø¬Ù‡Øª Ù‚Ø¨Ù„ÛŒ Ø­ÙØ¸ Ø´ÙˆØ¯
    if (Math.abs(player.vx) > 0.5) {
      player.facing = Math.sign(player.vx);
    }
    
    // Ø§Ø¹Ù…Ø§Ù„ Ø¬Ù‡Øª (1 Ø¨Ø±Ø§ÛŒ Ø±Ø§Ø³ØªØŒ -1 Ø¨Ø±Ø§ÛŒ Ú†Ù¾)
    ctx.scale(player.facing, 1);
    // ----------------------------------------------------

    ctx.drawImage(
      playerSprite, 
      currentFrame * spriteWidth, 0, spriteWidth, spriteHeight, 
      -player.radius, -player.radius, player.radius * 2, player.radius * 2 
    );

    ctx.restore();
  }
  // -----------------------------------------

// --- Û±. ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ø¯ÛŒÙˆØ§Ø± Ø¨Ù„ÙˆÚ©ÛŒ Ù…ØªØ­Ø±Ú© ---
   
  // Ø§ÛŒØ¬Ø§Ø¯ Ø­Ø±Ú©Øª Ø¨Ø± Ø§Ø³Ø§Ø³ Ù…ÙˆÙ‚Ø¹ÛŒØª Ø¹Ù…ÙˆØ¯ÛŒ Ú¯ÛŒØªâ€ŒÙ‡Ø§ Ø¨Ø±Ø§ÛŒ Ø­Ø³ ÙˆØ§Ù‚Ø¹ÛŒ Ø¬Ø§Ø¨Ø¬Ø§ÛŒÛŒ
  let scrollOffset = (gates.length > 0) ? (gates[0].y % blockSize) : 0;

  ctx.save();
  for (let y = -blockSize; y < canvas.height + blockSize; y += blockSize) {
      let drawY = y + scrollOffset;

      // Ø·Ø±Ø§Ø­ÛŒ Ø¨Ù„ÙˆÚ© Ø³Ù…Øª Ú†Ù¾
      ctx.fillStyle = "#34495e"; 
      ctx.fillRect(0, drawY, wallWidth, blockSize - 4);
      
      // Ù„Ø¨Ù‡ Ù†ÙˆØ±ÛŒ (Ù„ÛŒØ²Ø± Ù…Ø±Ú¯Ø¨Ø§Ø±)
      ctx.fillStyle = "#e74c3c";
      ctx.shadowBlur = 15;
      ctx.shadowColor = "#e74c3c";
      ctx.fillRect(wallWidth - 6, drawY + 5, 4, blockSize - 14);

      // Ø·Ø±Ø§Ø­ÛŒ Ø¨Ù„ÙˆÚ© Ø³Ù…Øª Ø±Ø§Ø³Øª
      ctx.fillStyle = "#34495e";
      ctx.shadowBlur = 0; // Ø±ÛŒØ³Øª Ø³Ø§ÛŒÙ‡ Ø¨Ø±Ø§ÛŒ Ø¨Ø¯Ù†Ù‡ Ø¨Ù„ÙˆÚ©
      ctx.fillRect(canvas.width - wallWidth, drawY, wallWidth, blockSize - 4);
      
      // Ù„Ø¨Ù‡ Ù†ÙˆØ±ÛŒ Ø±Ø§Ø³Øª
      ctx.fillStyle = "#e74c3c";
      ctx.shadowBlur = 15;
      ctx.fillRect(canvas.width - wallWidth + 2, drawY + 5, 4, blockSize - 14);
      ctx.shadowBlur = 0;
  }
  ctx.restore();



  if (flashAlpha > 0) {
    ctx.fillStyle = `rgba(255, 0, 0, ${flashAlpha})`;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    flashAlpha *= 0.9;
  }

if (currentGroundY < canvas.height + 100) {
    ctx.fillStyle = "#333";
    // Ú©Ù…ÛŒ Ø¹Ø±ÛŒØ¶â€ŒØªØ± Ù…ÛŒâ€ŒÚ©Ø´ÛŒÙ… ØªØ§ Ù…Ø·Ù…Ø¦Ù† Ø´ÙˆÛŒÙ… Ø±ÙˆÛŒ Ù„Ø¨Ù‡ Ø¯ÛŒÙˆØ§Ø±Ù‡Ø§ Ø±Ø§ Ù…ÛŒâ€ŒÙ¾ÙˆØ´Ø§Ù†Ø¯
    ctx.fillRect(-10, currentGroundY, canvas.width + 20, canvas.height);
  }

  // Û². Ø±Ø³Ù… Ù†ÙˆØ§Ø± Ù…Ø´Ú©ÛŒ Ø¨Ø§Ù„Ø§ÛŒ ØµÙØ­Ù‡ (Ù¾Ø³â€ŒØ²Ù…ÛŒÙ†Ù‡ Ø³ÙˆØ§Ù„ Ùˆ Ø§Ù…ØªÛŒØ§Ø²)
  ctx.fillStyle = "#1a1a1a";
  // Ø§ÛŒÙ† Ù†ÙˆØ§Ø± Ù‡Ù… Ø¨Ø§ÛŒØ¯ Ø±ÙˆÛŒ Ø¯ÛŒÙˆØ§Ø±Ù‡Ø§ Ø¨ÛŒØ§ÛŒØ¯
  ctx.fillRect(0, 0, canvas.width, 180);

  // Û³. Ø±Ø³Ù… Ù…ØªÙ† Ø³ÙˆØ§Ù„ (Ø±ÙˆÛŒ Ù†ÙˆØ§Ø± Ù…Ø´Ú©ÛŒ)
  let activeGate = gates.find(g => g.y < player.y);
  if (activeGate && activeGate.y > -50) {
    ctx.save();
    ctx.fillStyle = "cyan"; ctx.font = "bold 68px Tahoma"; ctx.textAlign = "center";
    ctx.globalAlpha = Math.min(1, (activeGate.y + 50) / 100); 
    ctx.fillText(activeGate.quiz.trait, canvas.width / 2, 110);
    ctx.restore();
  }

  // Û´. Ø±Ø³Ù… Ø§Ù…ØªÛŒØ§Ø²Ø§Øª (Ø±ÙˆÛŒ Ù†ÙˆØ§Ø± Ù…Ø´Ú©ÛŒ)
  ctx.fillStyle = "#ffd700"; ctx.font = "32px Arial"; ctx.textAlign = "left";
  ctx.fillText("SCORE: " + score, 25, 40);
  ctx.fillText("BEST: " + (highScore || 0), 25, 80);

  ctx.restore();
  requestAnimationFrame(gameLoop);
}

reset();
gameLoop();
</script>
</body>
</html>